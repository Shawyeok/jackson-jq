{
	"classes": [
		"net.thisptr.jackson.jq.Scope$DebugScopeFunction",
		"net.thisptr.jackson.jq.internal.functions.AtBase64Function",
		"net.thisptr.jackson.jq.internal.functions.AtHtmlFunction",
		"net.thisptr.jackson.jq.internal.functions.AtShFunction",
		"net.thisptr.jackson.jq.internal.functions.AtUriFunction",
		"net.thisptr.jackson.jq.internal.functions.BreakFunction",
		"net.thisptr.jackson.jq.internal.functions.ContainsFunction",
		"net.thisptr.jackson.jq.internal.functions.DelFunction",
		"net.thisptr.jackson.jq.internal.functions.EmptyFunction",
		"net.thisptr.jackson.jq.internal.functions.EndsWithFunction",
		"net.thisptr.jackson.jq.internal.functions.ErrorFunction",
		"net.thisptr.jackson.jq.internal.functions.ExplodeFunction",
		"net.thisptr.jackson.jq.internal.functions.FromEntriesFunction",
		"net.thisptr.jackson.jq.internal.functions.FromJsonFunction",
		"net.thisptr.jackson.jq.internal.functions.GroupFunction",
		"net.thisptr.jackson.jq.internal.functions.HasFunction",
		"net.thisptr.jackson.jq.internal.functions.ImplodeFunction",
		"net.thisptr.jackson.jq.internal.functions.IndexFunction",
		"net.thisptr.jackson.jq.internal.functions.IndicesFunction",
		"net.thisptr.jackson.jq.internal.functions.KeysFunction",
		"net.thisptr.jackson.jq.internal.functions.LengthFunction",
		"net.thisptr.jackson.jq.internal.functions.LTrimStrFunction",
		"net.thisptr.jackson.jq.internal.functions._MatchImplFunction",
		"net.thisptr.jackson.jq.internal.functions.MathFunction$AtanFunction",
		"net.thisptr.jackson.jq.internal.functions.MathFunction$CosFunction",
		"net.thisptr.jackson.jq.internal.functions.MathFunction$FloorFunction",
		"net.thisptr.jackson.jq.internal.functions.MathFunction$SinFunction",
		"net.thisptr.jackson.jq.internal.functions.MathFunction$SqrtFunction",
		"net.thisptr.jackson.jq.internal.functions.MaxFunction",
		"net.thisptr.jackson.jq.internal.functions.MinFunction",
		"net.thisptr.jackson.jq.internal.functions.NotFunction",
		"net.thisptr.jackson.jq.internal.functions.PathsFunction",
		"net.thisptr.jackson.jq.internal.functions.RangeFunction",
		"net.thisptr.jackson.jq.internal.functions.ReverseFunction",
		"net.thisptr.jackson.jq.internal.functions.RIndexFunction",
		"net.thisptr.jackson.jq.internal.functions.RTrimStrFunction",
		"net.thisptr.jackson.jq.internal.functions.SortFunction",
		"net.thisptr.jackson.jq.internal.functions.SplitFunction",
		"net.thisptr.jackson.jq.internal.functions.StartsWithFunction",
		"net.thisptr.jackson.jq.internal.functions._SubImplFunction",
		"net.thisptr.jackson.jq.internal.functions.ToEntriesFunction",
		"net.thisptr.jackson.jq.internal.functions.ToJsonFunction",
		"net.thisptr.jackson.jq.internal.functions.ToNumberFunction",
		"net.thisptr.jackson.jq.internal.functions.ToStringFunction",
		"net.thisptr.jackson.jq.internal.functions.TypeFunction"
	],
	"functions": [
		{"name": "@text", "body": "tostring"},
		{"name": "@json", "body": "tojson"},
		{"name": "@tsv", "body": "map(tostring | gsub(\"\\t\"; \"\\\\t\")) | join(\"\\t\")"},
		{"name": "@csv", "body": "map(if type == \"string\" then \"\\\"\" + gsub(\"\\\"\"; \"\\\"\\\"\") + \"\\\"\" else tostring end) | join(\",\")"},
		{"name": "paths", "args": [], "body": "paths(.)"},
		{"name": "arrays", "args": [], "body": "select(type == \"array\")"},
		{"name": "booleans", "args": [], "body": "select(type == \"boolean\")"},
		{"name": "nulls", "args": [], "body": "select(type == \"null\")"},
		{"name": "objects", "args": [], "body": "select(type == \"object\")"},
		{"name": "numbers", "args": [], "body": "select(type == \"number\")"},
		{"name": "strings", "args": [], "body": "select(type == \"string\")"},
		{"name": "values", "args": [], "body": "booleans, numbers, strings, arrays, objects"},
		{"name": "iterables", "args": [], "body": "arrays, objects"},
		{"name": "scalars", "args": [], "body": "nulls, booleans, numbers, strings"},
		{"name": "add", "args": [], "body": "reduce .[] as $item (null; . + $item)"},
		{"name": "min", "args": [], "body": "min(.)"},
		{"name": "max", "args": [], "body": "max(.)"},
		{"name": "sort", "args": [], "body": "sort(.)"},
		{"name": "unique", "args": [], "body": "group(.) | map(.[0])"},
		{"name": "unique", "args": ["f"], "body": "group(f) | map(.[0])"},
		{"name": "group", "args": [], "body": "group(.)"},
		{"name": "with_entries", "args": ["f"], "body": "to_entries | map(f) | from_entries"},
		{"name": "range", "args": ["size"], "body": "range(0; size; 1)"},
		{"name": "range", "args": ["x", "y"], "body": "range(x; y; 1)"},
		{"name": "select", "args": ["pred"], "body": "if pred then . else empty end"},
		{"name": "map", "args": ["f"], "body": "[.[] | f]"},
		{"name": "recurse", "args": ["f"], "body": "def r: ., (f | select(. != null) | r); r"},
		{"name": "recurse", "args": ["f", "cond"], "body": "def r: ., (f | select(cond) | r); r"},
		{"name": "recurse", "args": [], "body": "recurse(.[]?)"},
		{"name": "recurse_down", "args": [], "body": "recurse"},
		{"name": "last", "args": [], "body": ".[-1]"},
		{"name": "last", "args": ["stream"], "body": "reduce stream as $i (null; $i)"},
		{"name": "first", "args": [], "body": ".[0]"},
		{"name": "first", "args": ["stream"], "body": "foreach stream as $i ([false, null]; if .[0] then break else [true, $i] end; .[1])"},
		{"name": "nth", "args": ["n"], "body": "n as $n | .[$n]"},
		{"name": "transpose", "body": "if . == [] then [] else . as $in | (map(length) | max) as $max | length as $length | reduce range(0; $max) as $j ([]; . + [reduce range(0; $length) as $i ([]; . + [$in[$i][$j]])]) end"},
		{"name": "limit", "args": ["n", "exp"], "body": "n as $n | if $n < 0 then exp else foreach exp as $item ([$n, null]; if .[0] < 1 then break else [.[0] -1, $item] end; .[1]) end"},
		{"name": "nth", "args": ["n", "g"], "body": "n as $n | if $n < 0 then error(\"nth doesn't support negative indices\") else last(limit($n + 1; g)) end"},
		{"name": "any", "args": [], "body": "reduce .[] as $i (false; if . then break else . or $i end)"},
		{"name": "any", "args": ["predicate"], "body": "reduce .[] as $i (false; . or ($i | predicate))"},
		{"name": "any", "args": ["generator", "predicate"], "body": "[false, foreach generator as $i (false; if . then break elif $i | predicate then true else . end; if . then . else empty end)] | any"},
		{"name": "all", "args": [], "body": "reduce .[] as $i (true; if . | not then break else . and $i end)"},
		{"name": "all", "args": ["predicate"], "body": "reduce .[] as $i (true; . and ($i | predicate))"},
		{"name": "all", "args": ["generator", "predicate"], "body": "[true, foreach generator as $i (true; if . | not then break elif $i | predicate then . else false end; if . | not then . else empty end)] | all"},
		{"name": "flatten", "args": [], "body": "_flatten(-1)"},
		{"name": "flatten", "args": ["$x"], "body": "if $x < 0 then error(\"flatten depth must not be negative\") else _flatten($x) end"},
		{"name": "_flatten", "args": ["$x"], "body": "reduce .[] as $i ([]; if $i | type == \"array\" and $x != 0 then . + ($i | _flatten($x-1)) else . + [$i] end)"},
		{"name": "join", "args": ["$x"], "body": "reduce .[] as $i (null; (if .==null then \"\" else .+$x end) + ($i | if type==\"boolean\" or type==\"number\" then tostring else .//\"\" end)) // \"\""},
		{"name": "match", "args": ["re", "mode"], "body": "_match_impl(re; mode; false)|.[]"},
		{"name": "match", "args": ["$val"], "body": "($val|type) as $vt | if $vt == \"string\" then match($val; null) elif $vt == \"array\" and ($val | length) > 1 then match($val[0]; $val[1]) elif $vt == \"array\" and ($val | length) > 0 then match($val[0]; null) else error( $vt + \" not a string or array\") end"},
		{"name": "test", "args": ["re", "mode"], "body": "_match_impl(re; mode; true)"},
		{"name": "test", "args": ["$val"], "body": "($val|type) as $vt | if $vt == \"string\" then test($val; null) elif $vt == \"array\" and ($val | length) > 1 then test($val[0]; $val[1]) elif $vt == \"array\" and ($val | length) > 0 then test($val[0]; null) else error( $vt + \" not a string or array\") end"},
		{"name": "capture", "args": ["re", "mods"], "body": "match(re; mods) | reduce ( .captures | .[] | select(.name != null) | { (.name) : .string } ) as $pair ({}; . + $pair)"},
		{"name": "capture", "args": ["$val"], "body": "($val|type) as $vt | if $vt == \"string\" then capture($val; null) elif $vt == \"array\" and ($val | length) > 1 then capture($val[0]; $val[1]) elif $vt == \"array\" and ($val | length) > 0 then capture($val[0]; null) else error( $vt + \" not a string or array\") end"},
		{"name": "scan", "args": ["re"], "body": "scan(re; \"\")"},
		{"name": "scan", "args": ["re", "flags"], "body": "match(re; flags + \"g\") | if (.captures|length > 0) then [ .captures | .[] | .string ] else .string end"},
		{"name": "_nwise", "args": ["a", "$n"], "body": "if a|length <= $n then a else a[0:$n] , _nwise(a[$n:]; $n) end"},
		{"name": "_nwise", "args": ["$n"], "body": "_nwise(.; $n)"},
		{"name": "splits", "args": ["$re", "flags"], "body": ". as $s | [ match($re; \"g\" + flags) | (.offset, .offset + .length) ] | [0] + . +[$s|length] | _nwise(2) | $s[.[0]:.[1] ]"},
		{"name": "splits", "args": ["$re"], "body": "splits($re; null)"},
		{"name": "split", "args": ["$re", "flags"], "body": "[splits($re; flags)]"},
		{"name": "sub", "args": ["$re", "s"], "body": "_sub_impl($re; s; \"\")"},
		{"name": "sub", "args": ["$re", "s", "flags"], "body": "_sub_impl($re; s; flags)"},
		{"name": "gsub", "args": ["$re", "s", "flags"], "body": "_sub_impl($re; s; flags + \"g\")"},
		{"name": "gsub", "args": ["$re", "s"], "body": "_sub_impl($re; s; \"g\")"},
		{"name": "ascii_downcase", "body": "explode | map( if 65 <= . and . <= 90 then . + 32  else . end) | implode"},
		{"name": "ascii_upcase", "body": "explode | map( if 97 <= . and . <= 122 then . - 32  else . end) | implode"},
		{"name": "until", "args": ["cond", "next"], "body": "def _until: if cond then . else (next|_until) end; _until"},
		{"name": "while", "args": ["cond", "update"], "body": "def _while: if cond then ., (update | _while) else empty end; try _while catch if .==\"break\" then empty else . end"},
		{"name": "min_by", "args": ["f"], "body": "min(f)"},
		{"name": "max_by", "args": ["f"], "body": "max(f)"},
		{"name": "sort_by", "args": ["f"], "body": "sort(f)"},
		{"name": "unique_by", "args": ["f"], "body": "unique(f)"},
		{"name": "group_by", "args": ["f"], "body": "group(f)"},
		{"name": "leaf_paths", "args": [], "body": "paths(scalars)"},
		{"name": "walk", "args": ["f"], "body": ". as $in | if type == \"object\" then reduce keys[] as $key ( {}; . + { ($key):  ($in[$key] | walk(f)) } ) | f elif type == \"array\" then map( walk(f) ) | f else f end"},
		{"name": "in", "args": ["xs"], "body": ". as $x | xs | has($x)"},
		{"name": "inside", "args": ["xs"], "body": ". as $x | xs | contains($x)"},
		{"name": "combinations", "args": [], "body": "if length == 0 then [] else .[0][] as $x | (.[1:] | combinations) as $y | [$x] + $y end"},
		{"name": "combinations", "args": ["n"], "body": ". as $dot | [range(n) | $dot] | combinations"}
	]
}
